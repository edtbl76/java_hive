package com.concurrency.AdvancedConcurrency.ForkJoinPool;

import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;

public class FPMain {

    public static void main(String[] args) {

        // FJP
        ForkJoinPool pool = new ForkJoinPool();

        // FolderProcessors
        FolderProcessor markdown = new FolderProcessor(".", "md");
        FolderProcessor xml = new FolderProcessor(".", "xml");
        FolderProcessor clazz = new FolderProcessor("./target", "class");

        // execute
        pool.execute(markdown);
        pool.execute(xml);
        pool.execute(clazz);

        // instrum/status dump.
        do
        {
            System.out.printf("******************************************\n");
            System.out.printf("Main: Parallelism: %d\n", pool.getParallelism());
            System.out.printf("Main: Active Threads: %d\n", pool.getActiveThreadCount());
            System.out.printf("Main: Task Count: %d\n", pool.getQueuedTaskCount());
            System.out.printf("Main: Steal Count: %d\n", pool.getStealCount());
            System.out.printf("******************************************\n");
            try
            {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        } while ((!markdown.isDone()) || (!xml.isDone()) || (!clazz.isDone()));

        // turn off the pool.
        pool.shutdown();

        // Reporting.
        List<String> results;

        // write num of results generated by each task to console.
        results = markdown.join();
        System.out.printf("Markdown: %d files found.\n", results.size());

        results = xml.join();
        System.out.printf("XML     : %d files found.\n", results.size());

        results = clazz.join();
        System.out.printf("Class   : %d files found.\n", results.size());
    }
}

/*
    HOW IT WORKS:
    - every time the main task finds a folder, it forks off another task object for that folder to be processed.
        - (it sends it to pool using fork() method)
        - method returns immediately so it can continue processing content of the folder.
    - if a file matches the given extension, the file name is added to the list of results.

    - once the task has processed the content of the ASSIGNED FOLDER, it waits for "finalization" of forked tasks
        - everything it sent to the pool.
    - this begins w/ the call to join()
        - join() waits for all of its exec to be done and returns the value returned by compute().

    - the task then groups the results of all of the forked tasks to its own result set and returns that final list.
 */