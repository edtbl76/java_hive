# 6.3 Finding Exploitable Parallelism

### Quick Review
- Executor framework makes it easy to specify execution policy
- Executor requires that a task can be described as a Runnable.
- MOST Applications have an obvious task boundary
    - Single Client Request
    
#### Not-So-Obvious Boundaries
- Desktop Applications
    - (No one fucking cares)
- "Exploitable Parallelism in Single Client Request"
    - even in some server apps
    - Database Servers are a common source. 
    
### Problem To Solve In This Section
- Uses a sample component
    - varying degrees of concurrent

#### Component
Page renderer of a browser-based app
- takes page of HTML => renders it to image buffer
    
## 6.3.1. - Example - Sequential Page Renderer

### Sequential Processing 1.0
- This is the simplest approach
- as we get text markup, render it to image buffer
- as we hit the image refs, fetch image over network and draw it
into image buffer. 

#### Downsides
- This is going to be (very) slow
    - the page isn't going to be rendered until all markup is rendered
    as well as all images have been fetched and drawn. 
    
### Sequential Processing 2.0
(see Examples.SingleThredRenderer)
- Optimization of the first solution
    - provide rectangular placeholders for each image and store
the references
    - render all markup first
    - go back for a second pass to fetch/store the images.

#### Downsides
- this still sucks, because you are going to have to wait for all of the
images to be fetched sequentially and replaced on the screen.

### Remember what we learned!
- Image download is I/O intensive. 
    - i.e. CPU isn't doing much. 

## 6.3.2 Result-bearing Tasks (Callable and Future)

    Example:
    
        public interface Callable<V> {
            V call() throws Exception;
        }
        
        public intreface Future<V> {
            boolean cancel(boolean mayInterruptIfRunning);
            
            boolean isCancelled();
            
            boolean isDone();
            
            V get() throws InterruptedException, ExecutionException, CancellationException;
            
            V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException,
                CancellationException, TimeoutException; 
        }
        
Thread Safety
- submitting Runnable or Callable to Executor is a SAFE publication from the submitting thread
to the thread that will (eventually) run the task. 
- getting the result value for a Future is a SAFE publication from the thread in which it 
was compute to any thread that retrieves it. 

### The limits of Runnables
CAN
- write to log file
- place results in shared data structure

CANT
- return a value
- throw checked exceptions


### Callable
- Abstraction more suited for deferred computations than a Runnable.
- call()
    - main entry point
    - expected to return a value
        - Callable\<Void> is used to represent a non-value returning task
    - anticipates that an exception might be thrown.

#### Tasks that are Deferred Computations
- executing database query
- fetching a resource over the network
- computing complicated functions

#### Executors and Callables
- Executors have utility methods for wrapping tasks w/ a callable
    - (Tasks)
        - Runnable
        - java.security.PrivilegedAction

#### Runnables and Callables (Abstract Computational Tasks)
- FINITE
    - clear beginning
    - clear termination
- Task Lifecycle 
    - (in this case, we are referring to tasks executed by an executor)
    - CREATED
    - SUBMITTED
    - STARTED
    - COMPLETED
- Cancellation 
    - some tasks take a long time. 
    - CANCELLED is a valid state for a task that we have stopped. 
        - tasks that have been SUBMITTED (but not STARTED) can always be cancelled
        - tasks that have been STARTED, can SOMETIMES be cancelled if they are 
        responsive to interruption.

### Future
- A Future represents the lifecycle of a task. 
    - methods are used to 
        - check if task isCompleted
        - check if task isCancelled
        - cancel the task
        - get the result of a task. 
- Same implications as ExecutorService
    - lifecycle is unidirectional. 
    - once a task is completed, it stays in that state forever. 
    
#### get() in Future
- behavior varies on task state
    - isCompleted/isDone?
        - immediately throws an Exception
        - (else not complete) will block until task completes. 
    - if task completes by throwing an exception
        - get rethrows it wrapped in an ExecutionException
    - if task was cancelled
        - get throws CancellationException
       

NOTE: underlying exceptions can typically be retrieved w/ getCause()

- get is a stateful call
    - however, the state is abstracted from the caller, so the caller doesn't need to be
    aware of the state of the task. 
        - there is either a result, or there isn't. Period. 
    - this helps enforce the thread-safety based on the safe publication of the tasks.
- Exception Handling scenarios
    - task being queried has encountered an Exception
    - thread that called Future.get() was interrupted before the results were made
    available

#### Creating Features
- **submit** methods from ExecutorFramework all return a Future
    - submit Runnable/Callable to an executor
    - get back a Future in order to 
        - get result
        - cancel the task.
- explicitly instantiate a **FutureTask** for a given Runnable/Callable
    - (FutureTask implements Runnable, so it can be submitted to an Executor)
    - FutureTask can also be executed directly by its own inherited run() method.
    
#### newTaskFor
- default implementation creates a new FutureTask


    
    Example:
    
        protected <T> RunnableFuture<T> newTaskFor(Callable<T> task) {
            return new FutureTask<T>(task);
        }

- ExecutorService impls can override **newTaskFor** in **AbstractExecutorService**
    - controls instantiation of a Future corresponding to a submitted Callable/Runnable
    

## 6.3.3 Example - Page Renderer with Future

- We've already identified that sequential leads to poor utilization and responsiveness
- We've learned about Callables and Futures, which make the Executor framework more flexible

### Next Steps In Design
- divide renderer into 2 tasks
    - text renderer
    - image downloader
- why? 
    - we divided them based on the "usage" patterns
    - text rendering is CPU-bound. (computation)
    - image downloading is IO-bound. 
    - enables "parallelism" (concurrency!) of the two tasks

### Example (See code in Examples.FutureRenderer)
- Callable is used to download all of the images
    - (remember, good for I/O)
    - "deferred compute"
- Callable is submitted to the ExecutorService
    -  return's a future
- when main task needs to actually get an image it refers to the future
    - (via Future.get)
    - if the results are ready, they are returned, else we block
    
### Benefit
- we're exploiting some parallelism by rendering and downloading at the same time. 
- Once all of the images are downloaded, they are rendered onto the page
    - can we do better?...
    
    
## 6.3.4 Limitations of Parallelizing Heterogeneous Tasks

### Heterogeneous Tasks
- Different types of tasks make it easy to separate work. 
    - threadA does TaskType 1
    - threadB does TaskType 2

#### Challenges
- This pattern works well as long as "3 of task types" = "# of threads"
    - if more threads are added, it isn't immediately evident how we can assign those tasks
    to scale if those heterogeneous tasks are SEQUENTIAL. 
- This pattern works well as long as Task size is roughly the same
    - if Task A takes 10 times as long as Task B, then we've only sped up the total process
    by ~9%. 
- dividing tasks requires coordination overhead. 
    - in order for division/filtering to be worthwhile, it MUST result in performance
    productivity gains due to the parallelism being performed. 
    - (And that gain should also be greater than the cost of coordination)
    
### Reviewing FutureRenderer
- we divided based on task type
    - rendering text
    - downloading images
- what if the downloads take a LOT more time than the text rendering???
    - the performance boost might not be much different from the original sequential versions
    - AND the code is a lot more complex. 
- the absolute MAXIMUM performance increase available for an optimization from single-threaded to
two threads is a factor of 2. 

Is the juice worth the squeeze???

### Best Practice:

**Performance Optimizations are best achieved when it is possible to divide a program's
workload into a large number of independent HOMOGENEOUS tasks that can be processed
concurrently**

## 6.4.5 - CompletionService -> Executor meets BlockingQueue

### Limitations of Future
- Futures are "singular", so there isn't really a good way to handle a batch of computations
    - submit to an Executor returns 1 Future. 
    - we'd have to store a Future per task, and repeatedly poll for completion
    - kind of messy, error-prone. Lots of overhead. 
    
    
### CompletionService (Interface)
- combines capabilities of **Executor** and **BlockingQueue**
    - submit() Callable tasks for execution
    - supports queue-like methods to retrieve completed results
        - take() 
            - (Retrieves + removes head of queue)
            - waits/blocks (if necessary) until an element is available
        - poll(long timeout, TimeUnit unit)
            - (Retrieves + removes head of queue)
            - waits/blocks (if necessary) up to the given time until an element is
            available. 
    - completed results are returned as **Future**s once they are available. 

#### ExecutorCompletionService
- Concrete class that implements CompletionService
    - Implementation
        - constructor creates **BlockingQueue** to store completed results
        - **Future-Task** has a done() method that is called when computation 
        complete
        - submitted tasks are wrapped with **QueuingFuture** 
            - (Subtask of **FutureTask**)
            - overrides done() to place result on the **BlockingQueue**
        - **take()/poll()** methods delegate to **BlockingQueue** 
            - (blocks if results aren't yet available)
- delegates computation to an **Executor**


    Example of Queueing Future
    
        private class QueueingFuture<V> extends FutureTask<V> {
            QueuingFuture(Callable<V> callable) {
                super(callable);
            }
            
            QueueingFuture(Runnable task, V v) {
                super(task, v);
            }
            
            protected void done() {
                completionQueue.add(this);
            }
        }
        

## 6.3.6 - Example - page renderer with CompletionService

### What This Buys Us
- decreases the total runtime
- improved responsiveness

#### HOW
- downloading images is a collection of independent homogeneous tasks
    - create separate task for downloading EACH image. 
    - execute them in a thread pool. 
    - exploits parallelism!!! :)
- since downloads are occurring concurrently, the total amount of time spent downloading images
is reduced. 
- (More responsive) by fetching results directly from the **CompletionService** we render each image as soon as it
is available, rather than waiting for all of them to be downloaded

    
### Example Code
(See Examples.Renderer)
- a single **Executor** can be shared by multiple **ExecutionCompletionServices**
    - each ExecutionCompletionService that is private to a particular computation can
    share an Executor
- This pattern allows a **CompletionService** to behave to a BATCH of a computations in the 
same way that a **Future** behaves with a SINGLE computation.
- Accumulation/Notification can be managed by tracking the number of tasks submitted to 
CompletionService 
    - (increment for each new task)
    - (decrement for each completed task)
    - provides insight on how much work has been done, how much remains, and when it is
    all completed
    - (regardless of whether or not there is a shared Executor or not)
    
    
## 6.3.7 Placing Time Limits on Tasks
Sometimes after x amount of time has passed the result of a task may no longer be needed. 
- For expensive, long-running tasks, it makes sense to stop those tasks from further processing
so that the resources can be freed up for new requests. 
    
### Challenges
- (Primary Challenge) ensuring that we don't wait longer than the time budget to get() an answer or 
determine that we aren't going to get one. 
    - timed version of Future.get() supports this by throwing a **TimeoutException** if the result isn't ready within the predetermined timeout
- stopping timed tasks when their timeout has expired in order to make sure that they no
longer use resources on a result that isn't needed/consumed. 
    - Potential Approaches: 
        - have the task manage its own time allotment
            - aborting task if it runs out of time.
            - (or) cancelling task if timeout expires
            

#### Using Future to manage Task Cancellation
- if timed Future.get() throws TimeoutException
    - we can use the Future to perform the cancellation
- It is important to design/write tasks to be cancellable so that they may be
terminated early
    - this allows us to avoid wasting resources on work we don't ned. 

    
    Example:
    
        Page renderPageWithAd() throws InterruptedException {
            long endNanos = System.nanoTime() + TIME_BUDGET;
            Future<Ad> future = executor.submit(new FetchAdTask());
            
            // Render the page while waiting for the ad
            Page page = renderPageBody();
            
            Ad ad;
            try {
                
                /*
                    Only wait for remaining time budget
                    
                    NOTE: all timed methods in 
                    java.util.concurrent treat negative timeouts as 0, 
                    so even if this calculation ends up being negative, it
                    won't cause a problem. 
                    
                    
                */
                long remainingTime = endNanos - System.nanoTime();
                ad = future.get(remainingTime, NANOSECONDS);
            } catch (ExecutionException e) {
                ad = DEFAULT_AD;
            } catch (TimeoutException e) {
                ad = DEFAULT_AD;
                
                /*
                    The use of true means that the task thread CAN BE INTERRUPTED
                    if the task is currently running. 
                */
                future.cancel(true);
            }
            page.setAd(ad);
            return page;
        }
(Explained)
- Generates a composite web page
    - requested content + ad fetched from an ad server
- submits ad-fetching task to executor
- computes requested page content separately
     - if ad is fetched in time, we get the ad
     - else, there is a default advertisement 
     
     
## 6.3.8 - Example - Travel Reservations Portal
(See Examples.QuoteTask for code example)
- Use Case
    - user enters travel dates + requirements
    - portal fetches/displays bids from airlines/hotels/rental car companies
        - bids might invoke
            - web service
            - database query
            - EDI transaction 
            - something else
- How to handle concurrency
    - sequential or heterogeneous work management will most likely drive page loads
    by the slowest response time. 
    - However, the bids ARE heterogeneous and they are dictated by the third parties, so we
    have limitations
- Use of Time Budgeting buys back some control from the 3rd parties by allowing us to 
determine how to handle their slow ass APIs. 
    - if the provider calls don't respond, we can omit them from our result set completely
    - (or) we could display a placeholder that identifies which providers were too fucking slow. 
    
### Task Boundaries
- fetching a single bid from one company is independent of fetching bids from another
    - makes a good boundary to allow a concurrent implementation for bid retrieval
    
#### The Way We Know So far
- Create N tasks
- submit N tasks to a Thread Pool
- gather all of the **Future**s
- use a timed Future.get() to fetch each result via the Future

#### Easier Way - invokeAll
- invokeAll()
    - allows multiple tasks to be submitted to an **ExecutorService** AND to retrieve the 
    results.
        - parameter = collection of tasks
        - return value =  collection of Futures
        - collections have identical structures
            - Futures are added to returned collection in the same order imposed by the task
            collection's iterator
            - This effectively maps Futures to the Callables that they represent.
    - supports a timed version for timeboxing the tasks.
        - returns when
            - all tasks have completed
            - the CALLING thread is interrupted
            - timeout expires. 
        - any tasks that aren't finished when the timeout expires are CANCELLED
        - isCancelled() can be executed by the caller to determine which threads
        were punted. 
    
    